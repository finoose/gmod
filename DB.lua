timer.Simple( 3, function() chat.AddText(Color(170, 170, 170), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Loading......") end)
timer.Simple( 5, function() chat.AddText(Color(170, 170, 170), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Reading file. ragebot / legitbot") end)
timer.Simple( 5, function() chat.AddText(Color(170, 170, 170), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Initalizing b1g cheat.........") end)
timer.Simple( 9, function() chat.AddText(Color(170, 170, 170), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Ofc we dont have auth") end)
timer.Simple( 11, function() chat.AddText(Color(170, 170, 170), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Welcome to FinooseWare.cc", Color( math.random(0, 255), math.random(0, 255), math.random(0, 255), 255 ), " ",LocalPlayer():Name()  ) end)
timer.Simple( 15, function() chat.AddText(Color(170, 170, 170), "[", "noose.ga", "] ", Color( 255, 255, 255 ), "Privated cheat, Leak it and you will enjoy a bsod", Color( math.random(0, 255), math.random(0, 255), math.random(0, 255), 255 ), " ",LocalPlayer():Name()  ) end)
timer.Simple( 17, function() chat.AddText(Color(170, 170, 170), "[", "noose.ga", "] ", Color( 255, 255, 255 ), "ok? Thanks :3") end) 
surface.PlaySound("buttons/bell1.wav") 

local missingpng 					   = file.Read("materials/missing256.png", "GAME")
local idiot_antiscreengrab 			   = "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"
local idiot_antiscreengrab2 		   = "iVBORw0KGgoAAAANSUhEUgAAAAcAAAAECAIAAADNpLIqAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYSURBVBhXY2BgYmBmYGFgZEAFlIkyMAAACDAAKdIBq3cAAAAASUVORK5CYII="
render.Capture = function() return idiot_antiscreengrab end
render.Capture = function() return idiot_antiscreengrab end
render.Capture = function() return idiot_antiscreengrab end       -- litteraly stolen anti-screengrab from idiotbox
render.Capture = function() return idiot_antiscreengrab2 end 
render.Capture = function() return idiot_antiscreengrab2 end
render.Capture = function() return idiot_antiscreengrab2 end --  Secondary anti screengrab method, just to make sure
render.Capture = function() return chat.AddText(Color( 170, 170, 170 ), "[", "noose.ga", "] ", Color( 255, 255, 255 ), "Attempted screengrab has been detected. ")
end




local type = type;
local next = next;
 
local function Copy(tt, lt)
        local copy = {}
        if lt then
                if type(tt) == "table" then
                        for k,v in next, tt do
                                copy[k] = Copy(k, v)
                        end
                else
                        copy = lt
                end
                return copy
        end
        if type(tt) != "table" then
                copy = tt
        else
                for k,v in next, tt do
                        copy[k] = Copy(k, v)
                end
        end
        return copy
end

 /*
LOCALISING
*/


local cm = FindMetaTable"CUserCmd";
local surface = Copy(surface);
local vgui = Copy(vgui);
local input = Copy(input);
local Color = Color;
local ScrW, ScrH = ScrW, ScrH;
local gui = Copy(gui);
local math = Copy(math);
local file = Copy(file);
local util = Copy(util);
local fake = fake || LocalPlayer():EyeAngles() || Angle(0,0,0);
local CurTime = CurTime
local Arrival Public = table.Copy (_G) or {}
local surface = Copy(surface);

-- Localising end

surface.CreateFont("PlayerList", {
	font = "Visitor TT2 -BRK-",
	size = 12,
	weight = 600,
	shadow = true,
	antialias = false,
});
surface.CreateFont("deffontesp1", {
	font="TabLarge",
	size=17,
	weight=700
});
surface.CreateFont("deffontesp2", {
	font="TabLarge",
	size=10,
	weight=700
});

surface.CreateFont("MenuFont", {
	font = "Calibri",
	size = 18,
	antialias = true,
	outline  = true,
})

surface.CreateFont("TABFON",{font =  "Bebas Neue", size = 23, weight = 0})
surface.CreateFont("ESPFONT", {font = "Comfortaa", size = 18, weight = 400, outline = true})
surface.CreateFont("WATERMARK", {font = "Trebuchet", size = 25, weight = 550})
surface.CreateFont("TABFONT", {font = "Trebuchet", size =  18, weight = 550})
surface.CreateFont("WATERMARK3", {font = "Razer Regular", size = 25, weight = 550})
surface.CreateFont("MenuFnt", {font = "Comfortaa", size = 18, weight = 550})

surface.CreateFont("MenFont", {
	font = "HaxrCorp S8 Standard",
	size = 14,
	antialias = false,
	outline  = true,
})


surface.CreateFont("?Arrival Public2", {
	font = "Console",
	size = 19,
	weight = 900,
	shadow = false,
	antialias = false,
});

surface.CreateFont("MenuFont1", {
    font = "skrrtmenufont",
    size = 20,
    weight = 900,
    shadow = false,
    antialias = false,
});

surface.CreateFont("SelectFont", {
	font = "Console",
	size = 15,
	weight = 900,
	shadow = false,
	antialias = false,
});

surface.CreateFont("Title", {font = "Trench", size = 25,outline = 1})
surface.CreateFont("Menu", {font = "Trench", size = 30,outline = 1})
surface.CreateFont("Visual", {font = "Trench", size = 14, weight = 550})
surface.CreateFont("common", {font = "Trench", size = 10, outline =1 })


 
local options = {
   	["a"] = {
        	{
        	       {"Aimbot", 20, 20, 320, 390, 150},
        	       {"Enabled", "Checkbox", false, 0},
        	       {"Silent", "Checkbox", false, 0},
        	       {"Autofire", "Checkbox", false, 0},
        	       {"Autosnap", "Checkbox", false, 0},
        	       {"Auto Pistol", "Checkbox", false, 0},
         	       {"Non-Sticky", "Checkbox", false, 0},
        	       {"Bullettime", "Checkbox", false, 0},
        	       {"Rapid Fire", "Checkbox", false, 0},
        	       {"pSilent", "Checkbox", false, 0},
        	       {"Prediction", "Checkbox", false, 0},
		       {"AAA", "Checkbox", false, 0},
        	       {"AAA+", "Checkbox", false, 0},
		       {"No Spread", "Checkbox", false, 0},
		       {"Auto Wall", "Checkbox", false, 0},	
			   {"Aim FOV", "Slider", 25, 500,150},	
        },
        {
  	               {"Target", 353, 20, 350, 180, 150},
                       {"Selection", "Selection", "Distance", {"Distance", "Health", "Nextshot"}, 150 },
                       {"Bodyaim", "Checkbox", false, 0},
           	       {"Ignore Bots", "Checkbox", false, 0},
            	       {"Ignore Team", "Checkbox", false, 0},
            	       {"Ignore Friends", "Checkbox", false, 0},
            	       {"Snapline", "Checkbox", false, 0}, 
	},
	{
	    	       {"Anti-Aim", 353, 212, 350, 230, 140},
            	       {"Enabled", "Checkbox", false, 54},
	  	       {"X", "Selection", "Emotion", {"Emotion", "DOWN X", "Fake Down", "Anti p$ilent", "Dank", "Up", "Down"}, 100},
	  	       {"Y", "Selection", "Emotion", {"Emotion", "DOWN Y", "Fake Spin 2", "Fake Spin", "Fake Straight", "Fast Spin", "Middle Spin", "Slow Spin", "FakeAngle1", "Towards", "Fake AA", "Fake AA2","Fake Backwards", "Backwards",}, 100},
	  	       {"Max Y", "Slider", 50, 360, 100},
	 	       {"Min Y", "Slider", 0, 360, 100},
	   	       {"Emotion Random X", "Slider", 50, 100, 100},
	 	       {"Emotion Random Y", "Slider", 20, 100, 100},

 
		},
	},
  	["c"] = {
                {
	                {"ESP", 20, 20, 350, 270, 220},
		        {"Enabled", "Checkbox", false, 54},
		        {"Box", "Checkbox", true, 54},
		        {"Box Type", "Selection", "Edge", {"Edge", "Square", "AlphaBox", "Adaptive"}, 68},
		        {"Health Style", "Selection", "Left", {"Left", "Bottom", "Right", "Text"}, 68},
		        {"Name", "Checkbox", true, 54},
		        {"Rank", "Checkbox", true, 54},
		        {"Weapon", "Checkbox", true, 54},
		        {"XQZ", "Checkbox", true, 54},
		        {"Chams", "Checkbox", false, 54},
                        {"Skeleton", "Checkbox", false, 54},
		},
		{
                        {"Filter", 380, 220, 350, 180, 220},
                        {"Enemies only", "Checkbox", false, 54},
                        {"Distance", "Checkbox", false, 54},
                        {"Max Distance", "Slider", 0, 10000, 68},
                },
                {
                        {"Misc", 380, 20, 350, 190, 220},
			{"Spectator List", "Checkbox", false, 54},
			{"Online Admins", "Checkbox", false, 54},
			{"Watermark", "Checkbox", false, 54},
			{"No Sky", "Checkbox", false, 54},
			{"Thirdperson", "Checkbox", false, 54},
			{"FOV", "Slider", 90, 135, 88},
		},
		{
			{"Hud Paint", 20, 300, 350, 120, 220},
			{"Watermark", "Checkbox", false, 54},
			{"Rainbow Watermark", "Checkbox", false, 54},
			{"Crosshair", "Checkbox", false, 54},

		},
        },
       	["f"] = {
		{
			{"Misc", 10, 20, 350, 200, 120},		
			{"Bunnyhop", "Checkbox", false, 54},				
			{"Legit", "Checkbox", false, 54},
			{"Rage", "Checkbox", false, 54},
			{"Flashlight Spammer", "Checkbox", false, 54},
			{"Traitor Finder", "Checkbox", false, 54},
		},
		{
			{"Chat-Spams", 10, 233, 350, 211, 220},
			{"Enabled", "Checkbox", false, 54},		
			{"Chat-Spam1", "Checkbox", false, 54},
			{"Chat-Spam2", "Checkbox", false, 54},
			{"Chat-Spam3", "Checkbox", false, 54},
			{"Chat-Spam4", "Checkbox", false, 54},
			{"Chat-Spam5", "Checkbox", false, 54},
                },
                {
			{"Viewmodel", 370, 233, 350, 180, 220},
			{"No Hands", "Checkbox", false, 0},
			{"Wireframe", "Checkbox", false, 0},
			{"R", "Slider", 76, 255, 54},
			{"G", "Slider", 175, 255, 54},
			{"B", "Slider", 80, 255, 54},
		},
	},
        ["d"] = {
                {
                        {"Box - Team", 20, 20, 250, 175, 130},                    
			{"R", "Slider", 255, 255, 88},
                        {"G", "Slider", 255, 255, 88},
                        {"B", "Slider", 0, 255, 88},
                },
                {
                        {"Box - Enemy", 20, 205, 250, 175, 130},
                        {"R", "Slider", 180, 255, 88},
                        {"G", "Slider", 120, 255, 88},
                        {"B", "Slider", 0, 255, 88},
                },
                {
                        {"Chams - Team", 290, 20, 250, 175, 130},
                        {"Visible R", "Slider", 0, 255, 88},
                        {"Visible G", "Slider", 255, 255, 88},
                        {"Visible B", "Slider", 0, 255, 88},
                        {"Not Visible R", "Slider", 0, 255, 88},
                        {"Not Visible G", "Slider", 0, 255, 88},
                        {"Not Visible B", "Slider", 255, 255, 88},
                },
                {
             		{"Chams - Enemy", 290, 205, 250, 175, 130},
                        {"Visible R", "Slider", 255, 255, 88},
                        {"Visible G", "Slider", 0, 255, 88},
                        {"Visible B", "Slider", 0, 255, 88},
                        {"Not Visible R", "Slider", 180, 255, 88},
                        {"Not Visible G", "Slider", 120, 255, 88},
                        {"Not Visible B", "Slider", 0, 255, 88},

	        },
		{
			{"Crosshair Color", 560, 20, 250, 175, 130},
			{"R", "Slider", 255, 255, 88},
                        {"G", "Slider", 255, 255, 88},
                        {"B", "Slider", 0, 255, 88},
                },
        },
};
  
local order = {
    "a",
    "f",
    "c",
    "d",
};
 
local function updatevar( men, sub, lookup, new )
        for aa,aaa in next, options[men] do
                for key, val in next, aaa do
                        if(aaa[1][1] != sub) then continue; end
                        if(val[1] == lookup) then
                                val[3] = new;
                        end
                end
        end
end
 
local function loadconfig()
	if(not file.Exists("Aftermath V6_Legitbot.txt", "DATA")) then return end
	local tab = util.JSONToTable( file.Read("Aftermath V6_Legitbot.txt", "DATA") )
	local cursub
	for k,v in next, tab do
			if(not options[k]) then continue end
			for men, subtab in next, v do
					for key, val in next, subtab do
							if(key == 1) then cursub = val[1] continue end
							updatevar(k, cursub, val[1], val[3])
					end
			end
	end
end

local function loadconfig2()
	if(not file.Exists("Aftermath V6_ragebot.txt", "DATA")) then return end
	local tab = util.JSONToTable( file.Read("Aftermath V6_ragebot.txt", "DATA") )
	local cursub
	for k,v in next, tab do
			if(not options[k]) then continue end
			for men, subtab in next, v do
					for key, val in next, subtab do
							if(key == 1) then cursub = val[1] continue end
							updatevar(k, cursub, val[1], val[3])
					end
			end
	end
end
 
local function gBool(men, sub, lookup)
        if(!options[men]) then return; end
        for aa,aaa in next, options[men] do
                for key, val in next, aaa do
                        if(aaa[1][1] != sub) then continue; end
                        if(val[1] == lookup) then
                                return val[3];
                        end
                end
        end
end
 
local function gOption(men, sub, lookup)
        if(!options[men]) then return ""; end
        for aa,aaa in next, options[men] do
                for key, val in next, aaa do
                        if(aaa[1][1] != sub) then continue; end
                        if(val[1] == lookup) then
                                return val[3];
                        end
                end
        end
        return "";
end
 
local function gInt(men, sub, lookup)
        if(!options[men]) then return 0; end
        for aa,aaa in next, options[men] do
                for key, val in next, aaa do
                        if(aaa[1][1] != sub) then continue; end
                        if(val[1] == lookup) then
                                return val[3];
                        end
                end
        end
        return 0;
end
 
local function saveconfig()
	file.Write("Aftermath V6_Legitbot.txt", util.TableToJSON(options))
end

local function saveconfig2()
	file.Write("Aftermath V6_ragebot.txt", util.TableToJSON(options))
end
 
local mousedown;
local candoslider;
local drawlast;
 
local visible = {};
 
for k,v in next, order do
        visible[v] = false;
end
 
local function DrawBackground(w, h)
	surface.SetDrawColor(54,54,54);
	surface.DrawRect(0, 1, w, h);

        r = math.sin(CurTime()  *4)  *127 + 128
        g = math.sin(CurTime()  *4 + 2)  *127 + 128
        b = math.sin(CurTime()  *4 + 4)  *127 + 128

		local curcol = Color(45,55,45)

	  for i = 0, 32 do
		local curcol = Color(r, g , b)
        surface.SetDrawColor(curcol);
        curcol.r = curcol.r - 0;
        draw.RoundedBox(0, 0, 0 , 1000, 5, Color(r, g, b))
      end

	surface.SetFont("?Arrival Public2");

	local tw, th = surface.GetTextSize("cHoook");

	surface.SetTextPos(5, 15 - th / 2);

	surface.SetTextColor(53,53,53);
	
	if(!gBool("d", "Box - Team", "Menu Outline")) then return; end
	surface.DrawRect(0, 31, 2, h - 31);
	surface.DrawRect(0, h - 2, w, h);
	surface.DrawRect(w - 2, 31, 2, h);

end

local function MouseInArea(minx, miny, maxx, maxy)
	local mousex, mousey = gui.MousePos();
	return(mousex < maxx && mousex > minx && mousey < maxy && mousey > miny);
end
 
local function MouseInArea(minx, miny, maxx, maxy)
        local mousex, mousey = gui.MousePos();
        return(mousex < maxx && mousex > minx && mousey < maxy && mousey > miny);
end
 
local function DrawOptions(self, w, h)
	local mx, my = self:GetPos();

	local sizeper = (w - 10) / #order;

	local maxx = 5;

	for k,v in next, order do
		local bMouse = MouseInArea(mx + 5 + maxx, my + 31, mx + 5 + maxx + sizeper, my + 31 + 30);
		if(visible[v]) then
			local curcol = Color(170, 170, 170);
			for i = 0, 0 do
				surface.SetDrawColor(curcol);
				curcol.r, curcol.g, curcol.b = curcol.r + 3, curcol.g + 3, curcol.b + 3;
				surface.DrawLine( 0.9 + maxx, 60 + i, 0.9 + maxx + sizeper, 60 + i);

			end
		end
		if(bMouse && input.IsMouseDown(MOUSE_LEFT) && !mousedown && !visible[v]) then
			local nb = visible[v];
			for key,val in next, visible do
				visible[key] = false;
			end
			visible[v] = !nb;
		end
		surface.SetFont("MenuFont1");
		surface.SetTextColor(170, 170, 170);
		local tw, th = surface.GetTextSize(v);
		surface.SetTextPos( 5 + maxx + sizeper / 2 - tw / 2, 31 + 15 - th / 2 );
		surface.DrawText(v);
		maxx = maxx + sizeper;
	end
end

 
local function DrawCheckbox(self, w, h, var, maxy, posx, posy, dist)
	surface.SetFont("?Arrival Public2");
	surface.SetTextColor(170, 170, 170);
	surface.SetTextPos( 5 + posx + 15 + 5, 61 + posy + maxy );
	local tw, th = surface.GetTextSize(var[1]);
	surface.DrawText(var[1]);

	surface.SetDrawColor(64,64,64);

	surface.DrawRect( 5 + posx + 15 + 5 + dist + 2 + var[4], 61 + posy + maxy + 4, 10, 10);

	local mx, my = self:GetPos();

	local bMouse = MouseInArea(mx + 5 + posx + 15 + 5, my + 61 + posy + maxy, mx + 5 + posx + 15 + 5 + dist + 14 + var[4], my + 61 + posy + maxy + 16);

	if(bMouse) then
		surface.DrawRect( 5 + posx + 15 + 5 + dist + 2 + var[4], 61 + posy + maxy + 4, 10, 10);
	end

	if(var[3]) then
		local curcol = Color(144,255,0)
		surface.SetDrawColor(curcol);
		surface.DrawRect( 5 + posx + 15 + 5 + dist + 2 + var[4], 61 + posy + maxy + 4, 10, 10);
	end

	if(bMouse && input.IsMouseDown(MOUSE_LEFT) && !mousedown && !drawlast) then
		var[3] = !var[3];
	end
end

local function DrawSlider(self, w, h, var, maxy, posx, posy, dist)
	local curnum = var[3];
	local max = var[4];
	local size = var[5];
	surface.SetFont("?Arrival Public2");
	surface.SetTextColor(170, 170, 170);
	surface.SetTextPos( 5 + posx + 15 + 5, 61 + posy + maxy );
	surface.DrawText(var[1]);

	local tw, th = surface.GetTextSize(var[1]);

	surface.SetDrawColor(64,64,64);

	surface.DrawRect( 5 + posx + 15 + 5 + dist, 61 + posy + maxy + 9, size, 5);

	local ww = math.ceil(curnum * size / max);

	surface.SetDrawColor(144,255,0);

	surface.DrawRect( 3 + posx + 15 + 5 + dist + ww, 61 + posy + maxy + 11 - 5, 4, 12);

	surface.SetDrawColor(144,255,0);

	local tw, th = surface.GetTextSize(curnum..".00");

	surface.SetTextPos( 5 + posx + 15 + 5 + dist + (size / 2) - tw / 2, 61 + posy + maxy + 16);

	surface.DrawText(curnum..".00");

	local mx, my = self:GetPos();

	local bMouse = MouseInArea(5 + posx + 15 + 5 + dist + mx, 61 + posy + maxy + 9 - 5 + my, 5 + posx + 15 + 5 + dist + mx + size, 61 + posy + maxy + 9 - 5 + my + 12);

	if(bMouse && input.IsMouseDown(MOUSE_LEFT) && !drawlast && !candoslider) then
		local mw, mh = gui.MousePos();

		local new = math.ceil( ((mw - (mx + posx + 25 + dist - size)) - (size + 1)) / (size - 2) * max);
		var[3] = new;
	end
end
 
local notyetselected;

local function DrawSelect(self, w, h, var, maxy, posx, posy, dist)

	local size = var[5];
	local curopt = var[3];

	surface.SetFont("SelectFont");
	surface.SetTextColor(170, 170, 170);
	surface.SetTextPos( 5 + posx + 15 + 5, 61 + posy + maxy );
	local tw, th = surface.GetTextSize(var[1]);
	surface.DrawText(var[1]);

	surface.SetDrawColor(170, 170, 170);

	surface.DrawOutlinedRect( 25 + posx + dist, 61 + posy + maxy, size, 16);

	local mx, my = self:GetPos();

	local bMouse = MouseInArea( mx + 25 + posx + dist, my + 61 + posy + maxy, mx + 25 + posx + dist + size, my + 61 + posy + maxy + 16)

	local check = dist..posy..posx..w..h..maxy;

	if(bMouse || notyetselected == check) then


	end

	local tw, th = surface.GetTextSize(curopt);

	surface.SetTextPos( 25 + posx + dist + 5, 61 + posy + maxy + 6 - th / 2 + 2);

	surface.DrawText(curopt);

	if(bMouse && input.IsMouseDown(MOUSE_LEFT) && !drawlast && !mousedown || notyetselected == check) then
		notyetselected = check;
		drawlast = function()
			local maxy2 = 16;
			for k,v in next, var[4] do
				surface.SetDrawColor(45,55,45);
				surface.DrawRect( 25 + posx + dist, 61 + posy + maxy + maxy2, size, 16);
				local bMouse2 = MouseInArea( mx + 25 + posx + dist, my + 61 + posy + maxy + maxy2, mx + 25 + posx + dist + size, my + 61 + posy + maxy + 16 + maxy2)
				if(bMouse2) then
					surface.SetDrawColor(20,20,20, 129);
					surface.DrawRect( 25 + posx + dist, 61 + posy + maxy + maxy2, size, 16);
				end
				local tw, th = surface.GetTextSize(v);
				surface.SetTextPos( 25 + posx + dist + 5, 61 + posy + maxy + 6 - th / 2 + 2 + maxy2);
				surface.DrawText(v);
				maxy2 = maxy2 + 16;
				if(bMouse2 && input.IsMouseDown(MOUSE_LEFT) && !mousedown) then
					var[3] = v;
					notyetselected = nil;
					drawlast = nil;
					return;
				end
			end
			local bbMouse = MouseInArea( mx + 25 + posx + dist, my + 61 + posy + maxy, mx + 25 + posx + dist + size, my + 61 + posy + maxy + maxy2);
			if(!bbMouse && input.IsMouseDown(MOUSE_LEFT) && !mousedown) then
				 notyetselected = nil;
				 drawlast = nil;
				 return;
			end
		end
	end


end

local function DrawSubSub(self, w, h, k, var)
	local opt, posx, posy, sizex, sizey, dist = var[1][1], var[1][2], var[1][3], var[1][4], var[1][5], var[1][6];

	surface.SetDrawColor(170, 170, 170);

	local startpos = 61 + posy;

	surface.SetTextColor(0170, 170, 170);

	surface.SetFont("?Arrival Public2");

	local tw, th = surface.GetTextSize(opt);

	surface.DrawLine( 5 + posx, startpos, 5 + posx + 15, startpos);

	surface.SetTextPos( 5 + posx + 15 + 5, startpos - th / 2 );

	surface.DrawLine( 5 + posx + 15 + 5 + tw + 5, startpos, 5 + posx + sizex, startpos);

	surface.DrawLine( 5 + posx, startpos, 5 + posx, startpos + sizey);

	surface.DrawLine(5 + posx, startpos + sizey, 5 + posx + sizex, startpos + sizey );

	surface.DrawLine( 5 + posx + sizex, startpos, 5 + posx + sizex, startpos + sizey);

	surface.DrawText(opt);

	local maxy = 15;

	for k,v in next, var do
		if(k == 1) then continue; end
		if(v[2] == "Checkbox") then
			DrawCheckbox(self, w, h, v, maxy, posx, posy, dist);
		elseif(v[2] == "Slider") then
			DrawSlider(self, w, h, v, maxy, posx, posy, dist);
		elseif(v[2] == "Selection") then
			DrawSelect(self, w, h, v, maxy, posx, posy, dist);
		end
		maxy = maxy + 25;
	end
end
 
local function DrawSubSub(self, w, h, k, var)
	local opt, posx, posy, sizex, sizey, dist = var[1][1], var[1][2], var[1][3], var[1][4], var[1][5], var[1][6];

	surface.SetDrawColor(170, 170, 170);

	local startpos = 61 + posy;

	surface.SetTextColor(170, 170, 170);

	surface.SetFont("?Arrival Public2");

	local tw, th = surface.GetTextSize(opt);

	surface.DrawLine( 5 + posx, startpos, 5 + posx + 15, startpos);

	surface.SetTextPos( 5 + posx + 15 + 5, startpos - th / 2 );

	surface.DrawLine( 5 + posx + 15 + 5 + tw + 5, startpos, 5 + posx + sizex, startpos);

	surface.DrawLine( 5 + posx, startpos, 5 + posx, startpos + sizey);

	surface.DrawLine(5 + posx, startpos + sizey, 5 + posx + sizex, startpos + sizey );

	surface.DrawLine( 5 + posx + sizex, startpos, 5 + posx + sizex, startpos + sizey);

	surface.DrawText(opt);

	local maxy = 15;

	for k,v in next, var do
		if(k == 1) then continue; end
		if(v[2] == "Checkbox") then
			DrawCheckbox(self, w, h, v, maxy, posx, posy, dist);
		elseif(v[2] == "Slider") then
			DrawSlider(self, w, h, v, maxy, posx, posy, dist);
		elseif(v[2] == "Selection") then
			DrawSelect(self, w, h, v, maxy, posx, posy, dist);
		end
		maxy = maxy + 25;
	end
end

local function DrawSub(self, w, h)
	for k, v in next, visible do
		if(!v) then continue; end
		for _, var in next, options[k] do
			DrawSubSub(self, w, h, k, var);
		end
	end
end
 
local function DrawSaveButton(self, w, h)
	local curcol = Color(100, 100, 100, 75);
	local mx, my = self:GetPos();
	local bMouse = MouseInArea(mx + 30, my + h - 50, mx + 30 + 115, my + h - 50 + 30);
	if(bMouse) then
			curcol = Color(gInt("d", "Menu Color", "R") + 60,gInt("d", "Menu Color", "G") + 60,gInt("d", "Menu Color", "B") + 60, 75);
	end
	for i = 0, 30 do
			surface.SetDrawColor(curcol);
			for k,v in next, curcol do
					curcol[k] = curcol[k] - 2;
			end
	end
	surface.SetFont("MenuFont");
	surface.SetTextColor(170, 170, 170);
	local tw, th = surface.GetTextSize("Save Config");
	surface.SetTextPos( 30 + 60 - tw / 2, h - 50 + 15 - th / 2 );
	surface.DrawText("Save Config");
	if(bMouse && input.IsMouseDown(MOUSE_LEFT)) then
			saveconfig();
			timer.Create( "ChatPrint1", 0.1, 1, function() chat.AddText( Color(math.random(255), math.random(255), math.random(255)), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Config Saved!") end )
	end
end

 
local function DrawSaveButton2(self, w, h)
	local curcol = Color(100, 100, 100, 0);
	local mx, my = self:GetPos();
	local bMouse = MouseInArea(mx + 515, my + h - 50, mx + 617, my + h - 50 + 30);
	if(bMouse) then
			curcol = Color(gInt("d", "Menu Color", "Red") + 60,gInt("d", "Menu Color", "Green") + 60,gInt("d", "Menu Color", "Blue") + 60, 75);
	end
	for i = 0, 30 do
			surface.SetDrawColor(curcol);
			for k,v in next, curcol do
					curcol[k] = curcol[k] - 2;
			end
	end
	surface.SetFont("MenuFont");
	surface.SetTextColor(170, 170, 170);
	local tw, th = surface.GetTextSize("Save Config #2");
	surface.SetTextPos( 515 + 50 - tw / 2, h - 50 + 15 - th / 2 );
	surface.DrawText("Save Config #2");
	if(bMouse && input.IsMouseDown(MOUSE_LEFT)) then
			saveconfig2();
			timer.Create( "ChatPrint", 0.1, 1, function() chat.AddText( Color(math.random(255), math.random(255), math.random(255)), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Config #2 Saved!") end )
	end
end
local function DrawLoadButton(self, w, h)
	local curcol = Color(100, 100, 100, 75);
	local mx, my = self:GetPos();
	local bMouse = MouseInArea(mx + 160, my + h - 50, mx + 270, my + h - 50 + 30);
	if(bMouse) then
			curcol = Color(gInt("d", "Menu Color", "Red") + 60,gInt("d", "Menu Color", "Green") + 60,gInt("d", "Menu Color", "Blue") + 60, 75);
	end
	for i = 0, 30 do
			surface.SetDrawColor(curcol);
			for k,v in next, curcol do
					curcol[k] = curcol[k] - 2;
			end
	end
	surface.SetFont("MenuFont");
	surface.SetTextColor(170, 170, 170);
	local tw, th = surface.GetTextSize("Load Config");
	surface.SetTextPos( 117 + 100 - tw / 2, h - 50 + 15 - th / 2 );
	surface.DrawText("Load Config!");
	if(bMouse && input.IsMouseDown(MOUSE_LEFT)) then
			loadconfig();
			timer.Create( "ChatPrint2", 0.1, 1, function() chat.AddText( Color(math.random(255), math.random(255), math.random(255)), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Config Loaded!") end )
	end
end

 
local function DrawLoadButton2(self, w, h)
	local curcol = Color(100, 100, 100, 75);
	local mx, my = self:GetPos();
	local bMouse = MouseInArea(mx + 631, my + h - 50, mx + 735, my + h - 50 + 30);
	if(bMouse) then
			curcol = Color(gInt("d", "Menu Color", "Red") + 60,gInt("d", "Menu Color", "Green") + 60,gInt("d", "Menu Color", "Blue") + 60, 75);
	end
	for i = 0, 30 do
			surface.SetDrawColor(curcol);
			for k,v in next, curcol do
					curcol[k] = curcol[k] - 2;
			end
	end
	surface.SetFont("MenuFont");
	surface.SetTextColor(170, 170, 170);
	local tw, th = surface.GetTextSize("Load Config #2");
	surface.SetTextPos( 584 + 100 - tw / 2, h - 50 + 15 - th / 2 );
	surface.DrawText("Load Config #2");
	if(bMouse && input.IsMouseDown(MOUSE_LEFT)) then
			loadconfig2();
			timer.Create( "ChatPrint1", 0.1, 1, function() chat.AddText( Color(math.random(255), math.random(255), math.random(255)), "[", "FinooseWare.cc", "] ", Color( 255, 255, 255 ), "Config #2 Loaded!") end )
	end
end




loadconfig();

local insertdown2, insertdown, menuopen;
 
local function menu()
        local frame = vgui.Create("DFrame");
        frame:SetSize(850, 650);
        frame:Center();
        frame:SetTitle("");
        frame:MakePopup();
	frame:SlideDown(0.6)
        frame:ShowCloseButton(false);
       
        frame.Paint = function(self, w, h)
                if(candoslider && !mousedown && !drawlast && !input.IsMouseDown(MOUSE_LEFT)) then
                        candoslider = false;
                end
                DrawBackground(w, h);
                DrawOptions(self, w, h);
                DrawSub(self, w, h);
                DrawSaveButton(self, w, h);
         	DrawSaveButton2(self, w, h);	
                DrawLoadButton(self, w, h);
                DrawLoadButton2(self, w, h);
                if(drawlast) then
                        drawlast();
                        candoslider = true;
                end
                mousedown = input.IsMouseDown(MOUSE_LEFT);
        end
       
        frame.Think = function()
                if (input.IsKeyDown(KEY_INSERT) && !insertdown2) then
			frame:SlideUp(0.6)                        
                        menuopen = false;
                        candoslider = false;
                        drawlast = nil;
                end
        end
end
 
local function Think()
        if (input.IsKeyDown(KEY_INSERT) && !menuopen && !insertdown) then
                menuopen = true;
                insertdown = true;
                menu();
        elseif (!input.IsKeyDown(KEY_INSERT) && !menuopen) then
                insertdown = false;
        end
        if (input.IsKeyDown(KEY_INSERT) && insertdown && menuopen) then
                insertdown2 = true;
        else
                insertdown2 = false;
        end
end
 
hook.Add("Think", "", Think);
 
--[[
Actual codens
]]
 
 
local FindMetaTable = FindMetaTable;

local em = FindMetaTable"Entity";
local pm = FindMetaTable"Player";
local cm = FindMetaTable"CUserCmd";
local wm = FindMetaTable"Weapon";
local am = FindMetaTable"Angle";
local vm = FindMetaTable"Vector";

local Vector = Vector;
local player = Copy(player);
local Angle = Angle;
local me = LocalPlayer();
local render = Copy(render);
local cma = Copy(cam);
local Material = Material;
local CreateMaterial = CreateMaterial;
 
--[[
esp
]]
 
local function Filter(v)
        local enemy = gBool("c", "Filter", "Enemies only");
        local dist = gBool("c", "Filter", "Distance")
        if(enemy) then
                if(pm.Team(v) == pm.Team(me)) then return false; end
        end
        if(dist) then
                local maxdist = gBool("c", "Filter", "Max Distance");
                if( vm.Distance( em.GetPos(v), em.GetPos(me) ) > (maxdist * 5) ) then return false; end
        end
        return true;
end
 
local chamsmat = CreateMaterial("a", "VertexLitGeneric", {
        ["$ignorez"] = 1,
        ["$model"] = 1,
        ["$basetexture"] = "models/debug/debugwhite",
});
 
local chamsmat2 = CreateMaterial("@", "vertexlitgeneric", {
        ["$ignorez"] = 0,
        ["$model"] = 1,
        ["$basetexture"] = "models/debug/debugwhite",
});
 
local function GetChamsColor(v, vis)
        local pre = "Chams - Enemy";
        if(pm.Team(v) == pm.Team(me)) then
                pre = "Chams - Team";
        end
        if(vis) then
                local r = gInt("d", pre, "Visible R") / 255;
                local g = gInt("d", pre, "Visible G") / 255;
                local b = gInt("d", pre, "Visible B") / 255;
                return r,g,b;
        end
        local r = gInt("d", pre, "Not Visible R") / 255;
        local g = gInt("d", pre, "Not Visible G") / 255;
        local b = gInt("d", pre, "Not Visible B") / 255;
        return r,g,b;
end
 
local function Chams(v)
        if(gBool("c", "ESP", "XQZ")) then
                cam.Start3D();
                        cam.IgnoreZ(true);
                        em.DrawModel(v);
                        cam.IgnoreZ(false);
                cam.End3D();
        end
        if(gBool("c", "ESP", "Chams")) then
                cam.Start3D();
                       
                        render.MaterialOverride(chamsmat);
                        render.SetColorModulation(GetChamsColor(v));
                               
                        em.DrawModel(v);
                               
                        render.SetColorModulation(GetChamsColor(v, true));
                        render.MaterialOverride(chamsmat2);
                               
                        em.DrawModel(v);
                       
                cam.End3D();
        end
end
 
local function GetColor(v)
        if(pm.Team(v) == pm.Team(me)) then
                local r = gInt("d", "Box - Team", "R");
                local g = gInt("d", "Box - Team", "G");
                local b = gInt("d", "Box - Team", "B");
                return(Color(r, g, b, 220));
        end
        local r = gInt("d", "Box - Enemy", "R");
        local g = gInt("d", "Box - Enemy", "G");
        local b = gInt("d", "Box - Enemy", "B");
        return(Color(r, g, b, 220));
end
 
local function Get2DBounds(v)
	local min,max = v:OBBMins(),v:OBBMaxs()

	local corners = {
		Vector(min.x,min.y,min.z),
		Vector(min.x,min.y,max.z),
		Vector(min.x,max.y,min.z),
		Vector(min.x,max.y,max.z),
		Vector(max.x,min.y,min.z),
		Vector(max.x,min.y,max.z),
		Vector(max.x,max.y,min.z),
		Vector(max.x,max.y,max.z)
	}

	local minx,miny,maxx,maxy = math.huge, math.huge, -math.huge, -math.huge;

	for _, corner in next, corners do
		local screen = v:LocalToWorld(corner):ToScreen();
		minx,miny = math.min(minx,screen.x),math.min(miny,screen.y);
		maxx,maxy = math.max(maxx,screen.x),math.max(maxy,screen.y);
	end
	return minx,miny,maxx,maxy;
end


local function ESP(v)

local function Get2DBounds(v)
	local min,max = v:OBBMins(),v:OBBMaxs()

	local corners = {
		Vector(min.x,min.y,min.z),
		Vector(min.x,min.y,max.z),
		Vector(min.x,max.y,min.z),
		Vector(min.x,max.y,max.z),
		Vector(max.x,min.y,min.z),
		Vector(max.x,min.y,max.z),
		Vector(max.x,max.y,min.z),
		Vector(max.x,max.y,max.z)
	}

	local minx,miny,maxx,maxy = math.huge, math.huge, -math.huge, -math.huge;

	for _, corner in next, corners do
		local screen = v:LocalToWorld(corner):ToScreen();
		minx,miny = math.min(minx,screen.x),math.min(miny,screen.y);
		maxx,maxy = math.max(maxx,screen.x),math.max(maxy,screen.y);
	end
	return minx,miny,maxx,maxy;
end
local FindMetaTable = FindMetaTable;

local em = FindMetaTable"Entity";
	
	 local min, max = v:GetCollisionBounds()
        local pos = v:GetPos()
        local top, bottom = (pos + Vector(0, 0, max.z)):ToScreen(), (pos - Vector(0, 0, 8)):ToScreen()
        local middle = bottom.y - top.y
        local width = middle / 2.425
		
	if(gBool("c", "ESP", "Box") && gOption("c", "ESP", "Box Type") == "Edge") then   
local x1,y1,x2,y2 = Get2DBounds(v)
         --print(tostring(team.GetColor(v:Team())))
         surface.SetDrawColor(GetColor(v))
 
 
        surface.DrawLine( x1, y1, math.min( x1 + 5, x2 ), y1 )
        surface.DrawLine( x1, y1, x1, math.min( y1 + 5, y2 ) )
 
 
        surface.DrawLine( x2, y1, math.max( x2 - 5, x1 ), y1 )
        surface.DrawLine( x2, y1, x2, math.min( y1 + 5, y2 ) )
 
 
        surface.DrawLine( x1, y2, math.min( x1 + 5, x2 ), y2 )
        surface.DrawLine( x1, y2, x1, math.max( y2 - 5, y1 ) )
 
 
        surface.DrawLine( x2, y2, math.max( x2 - 5, x1 ), y2 )
        surface.DrawLine( x2, y2, x2, math.max( y2 - 5, y1 ) )

     end
	 

       local pos = em.GetPos(v);
	local pos, pos2 = vm.ToScreen(pos - Vector(0, 0, 5)), vm.ToScreen( pos + Vector(0, 0, 70 ) );
	local h = pos.y - pos2.y;
	local w = h / 2.2;
	if(gBool("c", "ESP", "Box") && gOption("c", "ESP", "Box Type") == "Square") then

		surface.SetDrawColor(GetColor(v));
		surface.DrawOutlinedRect( pos.x - w / 2, pos.y - h, w, h);
		surface.SetDrawColor(0, 0, 0, 220);
		surface.DrawOutlinedRect( pos.x - w / 2 - 1, pos.y - h - 1, w + 2, h + 2);
		surface.DrawOutlinedRect( pos.x - w / 2 + 1, pos.y - h + 1, w - 2, h - 2);

	end

	  --surface.DrawRect( pos.x - w / 2, pos.y - h, w, h);
  
    local pos = em.GetPos(v);
    local pos, pos2 = vm.ToScreen(pos - Vector(0, 2, 5)), vm.ToScreen( pos + Vector(0, 0, 70) );
    local h = pos.y - pos2.y;
    local w = h / 2.2; 
	
    if(gBool("c", "ESP", "Box") && gOption("c", "ESP", "Box Type") == "AlphaBox") then 
       
        surface.SetDrawColor(125,72,208,120);
        surface.DrawRect( pos.x - w / 1.7, pos.y - h, w, h);
    end   
     		if(gBool("c", "ESP", "Box") && gOption("c", "ESP", "Box Type") == "Adaptive") then 

			if (me:Team() == v:Team()) then
				surface.SetDrawColor(GetColor(v));
			else
				surface.SetDrawColor(Color(255,0,0))
			end
			surface.DrawOutlinedRect(bottom.x - width, top.y, width * 2, middle)
			surface.SetDrawColor(Color(0,0,0))
			surface.DrawOutlinedRect(bottom.x - width - 1, top.y - 1, width * 2 + 2, middle + 2)
			surface.DrawOutlinedRect(bottom.x - width + 1, top.y + 1, width * 2 - 2, middle - 2)




   end

if(gBool("c", "ESP", "Health Style") && gOption("c", "ESP", "Health Style") == "Left") then
        local hp = em.Health(v) * h / 100;
        if(hp > h) then hp = h; end
        local diff = h - hp;
        surface.SetDrawColor(0, 0, 0, 255);
        surface.DrawRect(pos.x - w / 2 - 5, pos.y - h - 1, 3, h + 2);
        surface.SetDrawColor( ( 100 - em.Health(v) ) * 2.55, em.Health(v) * 2.55, 0, 255);
        surface.DrawRect(pos.x - w / 2 - 4, pos.y - h + diff, 1, hp);



    end

    if(gBool("c", "ESP", "Health Style") && gOption("c", "ESP", "Health Style") == "Right") then

            local health = math.Clamp(v:Health(), 0, 100)
            local green = health * 2.55
            local red = 255 - green

        local min, max = v:GetCollisionBounds()
        local pos = v:GetPos()
        local top, bottom = (pos + Vector(0, 0, max.z)):ToScreen(), (pos - Vector(0, 0, 8)):ToScreen()
      local middle = bottom.y - top.y
        local width = middle / 2.425
            surface.SetDrawColor(Color(0, 0, 0))
            surface.DrawRect(bottom.x + width + 2, top.y - 1, 4, middle + 2)
            surface.SetDrawColor(Color(red, green, 0))
            local height = health * middle / 100
            surface.DrawRect(bottom.x + width + 3, top.y + (middle - height), 2, height)
    end



    if(gBool("c", "ESP", "Health Style") && gOption("c", "ESP", "Health Style") == "Bottom") then
     local hp = em.Health(v) * h / 220;
      if(hp > h) then hp = h; end
      local diff = h - hp;
      local GermanX = pos.x - w / 2
      local GermanY = pos.y + 1
      local Width =  w + 2
      local GermanW = diff
      local GermanColor = 255, 100, 100

      surface.SetDrawColor(0,0,0)
      surface.DrawRect( GermanX, GermanY, Width, 5 );

      surface.SetDrawColor( ( 100 - em.Health(v) ) * 2.55, em.Health(v) * 2.55, 0, 255);
      surface.DrawRect( GermanX+1, GermanY+1, hp, 3);
    end
if(gBool("c", "ESP", "Health Style") && gOption("c", "ESP", "Health Style") == "Text") then
local pos = em.GetPos(v);
	local min, max = em.GetCollisionBounds(v);
	local pos2 = pos + Vector(0, 0, max.z);
	local pos = vm.ToScreen(pos);
	local pos2 = vm.ToScreen(pos2);
	local hh = 0;
	local h = pos.y - pos2.y;
	local w = h / 2;
	local color = team.GetColor(pm.Team(v));
	local hh = 0;
	
	local pos = em.GetPos( v )
	local min, max = em.GetCollisionBounds(v)
	local pos2 = pos + Vector(0, 0, max.z)
	local pos = vm.ToScreen(pos)
	local pos2 = vm.ToScreen(pos2)
	local hh = 0
	hh = hh + 1;
        local col1 = Color((100 - em.Health(v)) * 2.55, em.Health(v) * 2, 0);
        draw.SimpleText(em.Health(v).."HP", "TargetID", pos.x, pos.y - 2 + hh, col1, 1, 0);
        hh = hh + 9;
        end

	surface.SetFont("ESPFONT");

	surface.SetTextColor(170, 170, 170 , 255);

	if(gBool("c", "ESP", "Name")) then

		local tw, th = surface.GetTextSize(pm.Name(v));

		surface.SetTextPos( pos.x - tw / 2, pos.y - h + 2 - th );

		surface.DrawText(pm.Name(v));

	end

		drawpos = 0

        if(gBool("c", "ESP", "Weapon")) then
			local wep = v:GetActiveWeapon()
			if wep and wep != NULL then
				draw.SimpleText(wep.GetPrintName and wep:GetPrintName() or wep:GetClass(), "ESPFONT", bottom.x, bottom.y + drawpos, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				drawpos = drawpos + 10
			end
		end

       
        if(gBool("c", "ESP", "Skeleton")) then
                local origin = em.GetPos(v);
                for i = 1, em.GetBoneCount(v) do
                        local parent = em.GetBoneParent(v, i);
                        if(!parent) then continue; end
                        local bonepos, parentpos = em.GetBonePosition(v, i), em.GetBonePosition(v, parent);
                        if(!bonepos || !parentpos || bonepos == origin) then continue; end
                        local bs, ps = vm.ToScreen(bonepos), vm.ToScreen(parentpos);
                        surface.SetDrawColor(255, 255, 255);
                        surface.DrawLine(bs.x, bs.y, ps.x, ps.y);
                end
        end
       
end
 
local aimtarget;
 
 
hook.Add("HUDPaint", "", function()
        if(aimtarget && gBool("Config", "Target", "Snapline")) then
                local pos = vm.ToScreen(em.LocalToWorld(aimtarget, em.OBBCenter(aimtarget)));
                surface.SetDrawColor(255, 255, 255);
                surface.DrawLine(ScrW() / 2, ScrH() / 2, pos.x, pos.y);
        end
        if(!gBool("c", "ESP", "Enabled")) then return; end
        for k,v in next, player.GetAll() do
                if(!em.IsValid(v) || em.Health(v) < 1 || v == me || em.IsDormant(v)) then continue; end
                if(!Filter(v)) then continue; end
                ESP(v);
        end
end);
 
hook.Add("RenderScreenspaceEffects", "", function()
        if(!gBool("c", "ESP", "Enabled")) then return; end
        for k,v in next, player.GetAll() do
                if(!em.IsValid(v) || em.Health(v) < 1 || v == me || em.IsDormant(v)) then continue; end
                if(!Filter(v)) then continue; end
                Chams(v);
        end
end);
 
--[[
aimer
]]
 
local table = Copy(table);
local dists = {};
 
local function GetPos(v)
 
        if(gBool("Config", "Target", "Bodyaim")) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end
 
        local eyes = em.LookupAttachment(v, "eyes");
       
        if(!eyes) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end
       
        local pos = em.GetAttachment(v, eyes);
       
        if(!pos) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end
       
        return(pos.Pos);
end
 
local aimignore;
 
local function Valid(v)
        if(!v || !em.IsValid(v) || v == me || em.Health(v) < 1 || em.IsDormant(v) || pm.Team(v) == 1002 || (v == aimignore && gOption("Config", "Target", "Selection") == "Nextshot")) then return false; end
        if(gBool("Config", "Target", "Ignore Bots")) then
                if(pm.IsBot(v)) then return false; end
        end
        if(gBool("Config", "Target", "Ignore Team")) then
                if(pm.Team(v) == pm.Team(me)) then return false; end
        end
        if(gBool("Config", "Target", "Ignore Friends")) then
                if(pm.GetFriendStatus(v) == "friend") then return false; end
        end
        local tr = {
                start = em.EyePos(me),
                endpos = GetPos(v),
                mask = MASK_SHOT,
                filter = {me, v},
        };
        return(util.TraceLine(tr).Fraction == 1);
end
 
local function gettarget()
 
        local opt = gOption("Config", "Target", "Selection");
       
        local sticky = gOption("Config", "Aimbot", "Non-Sticky");
       
        if(opt == "Distance") then
 
                if( !sticky && Valid(aimtarget) ) then return; end
 
                dists = {};
               
                for k,v in next, player.GetAll() do
                        if(!Valid(v)) then continue; end
                        dists[#dists + 1] = { vm.Distance( em.GetPos(v), em.GetPos(me) ), v };
                end
               
                table.sort(dists, function(a, b)
                        return(a[1] < b[1]);
                end);
               
                aimtarget = dists[1] && dists[1][2] || nil;
               
        elseif(opt == "Health") then
               
                if( !sticky && Valid(aimtarget) ) then return; end
 
                dists = {};
               
                for k,v in next, player.GetAll() do
                        if(!Valid(v)) then continue; end
                        dists[#dists + 1] = { em.Health(v), v };
                end
               
                table.sort(dists, function(a, b)
                        return(a[1] < b[1]);
                end);
               
                aimtarget = dists[1] && dists[1][2] || nil;
               
        elseif(opt == "Nextshot") then
                if( !sticky && Valid(aimtarget) ) then return; end
                aimtarget = nil;
                local allplys = player.GetAll();
                local avaib = {};
                for k,v in next,allplys do
                        avaib[math.random(100)] = v;
                end
               
                for k,v in next, avaib do
                        if(Valid(v)) then
                                aimtarget = v;
                        end
                end
        end
               
end
 
 
local cones = {};
 
local pcall = pcall;
local require = require;
 
local nullvec = Vector() * -1;
 
local CurTime = CurTime;
local servertime=0;
local bit = Copy(bit);

/* pPrediction */

    local function predict()
    local origVel = EntM.GetVelocity(me);
    local origAngles = EntM.EyeAngles(me);
    local m_vecForward;
    local m_vecRight;
    local m_vecUp;

    m_vecForward = AngM.Forward(origAngles);
    m_vecRight = AngM.Right(origAngles);
    m_vecUp = AngM.Up(origAngles);

    local fallVelocity = 0;

    if(!EntM.IsOnGround(me)) then
        fallVelocity = -origVel[3];

    local moveType = EntM.GetMoveType(me);
  end
end

/* FakeLag Prediction */

local function FakelagPrediction(v)
if(gBool("a", "Aimbot", "Prediction")) then
  if(!fakelagBucket[v]) then
      fakelagBucket[v] = {
          v:GetVelocity(),
          v:GetPos(),
          0,
      };
  end
end
  local oldVel = fakelagBucket[v][1];
  local oldPos = fakelagBucket[v][2];

  fakelagBucket[v][1] = v:GetVelocity();
  fakelagBucket[v][2] = v:GetPos();

  if(oldVel == nullVel) then
      fakelagBucket[v][3] = 0;
      return;
  end

  if(fakelagBucket[v][1] == oldVel && oldPos == fakelagBucket[v][2]) then
      fakelagBucket[v][3] = fakelagBucket[v][3] + 1;

      return(oldVel + (oldVel * (engine.TickInterval() * fakelagBucket[v][3])));
  else
      fakelagBucket[v][3] = 0;
  end

end

function predict(cmd,target, predPos)
  predPos = predPos + (ply:GetVelocity() * engine.TickInterval() * RealFrameTime() ) - (me:GetVelocity(me) * engine.TickInterval() * RealFrameTime() )
  return predPos
end

/* AAA */
local function AAA()
if(!gBool("a", "Aimbot", "AAA+")) then return; end
	for k,v in next, player.GetAll() do
		if(v == me) then continue; end
		local correctedpitch = v:EyeAngles().x;
		local correctedyaw = v:EyeAngles().y;

		local sid = v:SteamID();
		if(!aaaTable[sid]) then
			aaaTable[sid] = {["friend"] = false, ["pitch"] = 0, ["yaw"] = 0};
		end

		local tab = aaaTable[sid];

		if(tab["pitch"] == 0) then //auto
			if(correctedpitch >= 89 && correctedpitch < 180) then
				correctedpitch = 89;
			elseif(correctedpitch >= 180 && correctedpitch < 290) then
				correctedpitch = -89;
			end

		elseif(tab["pitch"] == -632) then //Drag
			correctedpitch = 360;
		elseif(tab["pitch"] == math.random(-0 + -1111111111111111111111111111111)) then //Drag
			correctedpitch = 360;
		elseif(tab["pitch"] == math.random(-1 + -9999999999999999999999999999999)) then //Drag
			correctedpitch = 360;
		elseif(tab["pitch"] == math.random(1 + 999999999999999999999999999999999)) then //Drag
			correctedpitch = 180;
		elseif(tab["pitch"] == 0.2) then //Fa1
			correctedpitch = 180;
		elseif(tab["pitch"] == 1) then //idk
			correctedpitch = 180;
		elseif(tab["pitch"] == -629) then //Correction
			correctedpitch = 180;
		elseif(tab["pitch"] == -181) then //FakeDown
			correctedpitch = 180;
		elseif(tab["pitch"] == 180) then //Down
			correctedpitch = 360;
		elseif(tab["pitch"] == -90) then //Sideways
			correctedpitch = 180;
		elseif(tab["pitch"] == -612.3) then //XD
			correctedpitch = 180;
		elseif(tab["pitch"] == -632) then //Woody
			correctedpitch = 180;
		elseif(tab["pitch"] == -00.1231234235) then //Woody
			correctedpitch = 80;
		elseif(tab["pitch"] == 181) then //AntiSpine
			correctedpitch = 180;

		elseif(tab["pitch"] == 1) then //Toggle
			correctedpitch = -632;
		elseif(tab["pitch"] == 180.087929) then //Precision
			correctedpitch = 89;
		elseif(tab["pitch"] == -22.001) then //Aden
			correctedpitch = 180;
		elseif(tab["pitch"] == -541) then //AntiKaliCheat
				if(correctedpitch >= 360 && correctedpitch < 180 && correctedpitch != 181 && correctedpitch ) then
				correctedpitch = 89;
		elseif(correctedpitch >= 181) then
				correctedpitch = -89;
				end
		elseif(tab["pitch"] == -629) then //AntiKaliCheat2
				if(correctedpitch >= 360 && correctedpitch < 180 && correctedpitch != 181 && correctedpitch ) then
				correctedpitch = 89;
				elseif(correctedpitch >= 181) then
				correctedpitch = -89;
				end
		elseif(tab["pitch"] == -541) then //Dank Angle -- FUCKED RED take it up the ass
			correctedpitch = 360;
		elseif(tab["pitch"] == -629) then //SS/Aftermath
		if(correctedpitch >= 360 && correctedpitch < -360 && correctedpitch != 360 && correctedpitch ) then
		correctedpitch = -360;
		correctedpitch = -360;
				end
		elseif(tab["pitch"] == 6) then // up
			correctedpitch = -89;
		end
       end
end


/* AAA */
local function AAA()
if(!gBool("a", "Aimbot", "AAA")) then return; end
	for k,v in next, player.GetAll() do
		if(v == me) then continue; end
		local correctedpitch = v:EyeAngles().x;
		local correctedyaw = v:EyeAngles().y;

		local sid = v:SteamID();
		if(!aaaTable[sid]) then
			aaaTable[sid] = {["friend"] = false, ["pitch"] = 0, ["yaw"] = 0};
		end

		local tab = aaaTable[sid];

		if(tab["pitch"] == 0) then //auto
			if(correctedpitch >= 89 && correctedpitch < 180) then
				correctedpitch = 89;
			elseif(correctedpitch >= 180 && correctedpitch < 290) then
				correctedpitch = -89;
			end

		elseif(tab["pitch"] == -632) then //Drag
			correctedpitch = 360;

		elseif(tab["pitch"] == 181) then //AntiSpine
			correctedpitch = 180;

		elseif(tab["pitch"] == 1) then //Toggle
			correctedpitch = -632;
		elseif(tab["pitch"] == 180.087929) then //Precision
			correctedpitch = 89;
		elseif(tab["pitch"] == -22.001) then //Aden
			correctedpitch = 180;
		elseif(tab["pitch"] == -541) then //AntiKaliCheat
				if(correctedpitch >= 360 && correctedpitch < 180 && correctedpitch != 181 && correctedpitch ) then
				correctedpitch = 89;
		elseif(correctedpitch >= 181) then
				correctedpitch = -89;
				end
		elseif(tab["pitch"] == -629) then //AntiKaliCheat2
				if(correctedpitch >= 360 && correctedpitch < 180 && correctedpitch != 181 && correctedpitch ) then
				correctedpitch = 89;
				elseif(correctedpitch >= 181) then
				correctedpitch = -89;
				end
		elseif(tab["pitch"] == -541) then //Dank Angle -- FUCKED RED take it up the ass
			correctedpitch = 360;
		elseif(tab["pitch"] == -629) then //SS/Aftermath
		if(correctedpitch >= 360 && correctedpitch < -360 && correctedpitch != 360 && correctedpitch ) then
		correctedpitch = -360;
		correctedpitch = -360;
				end
		elseif(tab["pitch"] == 6) then // up
			correctedpitch = -89;
		end

		if(tab["yaw"] == 0) then //auto
		elseif(tab["yaw"] == -541) then -- idk
			if(tab["yaw"] == 360) then //auto
		elseif(tab["yaw"] == -90) then
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == -630) then
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == -180.11235) then
			correctedyaw = correctedyaw - 80;
		elseif(tab["yaw"] == 0.1) then -- lol
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == -612.3) then -- lol
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == math.random(1 + 9999999999999999999999999999999999)) then -- lol
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == math.random(-234531 + -8999999999999999999999999999999999)) then -- lol
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == math.random(-1 + -9999999999999999999999999999999999)) then -- lol
			correctedyaw = correctedyaw - 180;
		elseif(tab["yaw"] == 0.2) then -- lol
			correctedyaw = correctedyaw - 80;
		elseif(tab["yaw"] == -333.0001) then -- lol
			correctedyaw = correctedyaw - 90;
		elseif(tab["yaw"] == -23.001) then -- kek ily Not
			correctedyaw = -correctedyaw - 90;
		elseif(tab["yaw"] == -630) then -- Rip Older Aftermath
			correctedyaw = correctedyaw - 90;
		elseif(tab["yaw"] == -540) then -- Rip Red
			correctedyaw = correctedyaw - 90;
		elseif(tab["yaw"] == 373) then -- Seems like a good yaw
			correctedyaw = correctedyaw - 90;
		elseif(tab["yaw"] == 180) then
			correctedyaw = correctedyaw + 90;
		else
			correctedyaw = correctedyaw - 180;
		end
	end
		pitcharray[v:EntIndex()] = correctedpitch;

		v:SetPoseParameter("aim_pitch", correctedpitch);
		v:SetPoseParameter("body_yaw", 0);
		v:SetPoseParameter("aim_yaw", 0);
		v:InvalidateBoneCache();
		v:SetRenderAngles(Angle(0, math.NormalizeAngle(correctedyaw), 0));
	end
end
 
local function Autofire(ucmd)
        if(pm.KeyDown(me, 1) && gBool("Config", "Aimbot", "Auto Pistol")) then
                cm.SetButtons(ucmd, bit.band( cm.GetButtons(ucmd), bit.bnot( 1 ) ) );
        else
                cm.SetButtons(ucmd, bit.bor( cm.GetButtons(ucmd), 1 ) );
        end
end
 
local function WeaponCanFire()
        local w = pm.GetActiveWeapon(me);
        if(!w || !em.IsValid(w) || !gBool("Config", "Aimbot", "Bullettime")) then return true; end
        return( servertime >= wm.GetNextPrimaryFire(w) );
end



local function pBhoop(ucmd)
if(!gBool("f", "Misc", "Legit")) then return; end
	if (!LocalPlayer():IsTyping() && !LocalPlayer():IsOnGround() && LocalPlayer():Alive()) then
		ucmd:RemoveKey(2)
		if (ucmd:GetMouseX() < 0) then
			ucmd:SetSideMove(-31 ^ 2 + 39) // extra memey take that ari
		elseif(ucmd:GetMouseX() > 0) then
			ucmd:SetSideMove(31 ^ 2 + 39)
		end
	end
end

local function Bunnyhop(ucmd)
local duckEstimate = math.Round(58 + 1 / engine.TickInterval());
if(!gBool("f", "Misc", "Bunnyhop") || em.GetMoveType(me) == MOVETYPE_NOCLIP || me:Health() < 1) then return; end
	if(cm.KeyDown(ucmd, 2) && !em.IsOnGround(me)) then
		cm.SetButtons(ucmd, bit.band( cm.GetButtons(ucmd), bit.bnot( 2 ) ) );
	end
end

as_max = 10^4
as_l = 400

local function autostrafe(ucmd)
if(!gBool("f", "Misc", "Rage")) then return; end
	if me:IsOnGround() and ucmd:KeyDown(IN_JUMP) then
		ucmd:SetButtons(bit.bor(ucmd:GetButtons(), IN_JUMP))
		if autostrafe then
			ucmd:SetForwardMove(as_max)
		end
	else
		if autostrafe and ucmd:KeyDown(IN_JUMP) then
			local mousex = ucmd:GetMouseX()
			if -1 > mousex or mousex > 1 then
				ucmd:SetSideMove((mousex > 0) and 400 or -400)
			else
				ucmd:SetForwardMove(5850 / me:GetVelocity():Length2D())
				ucmd:SetSideMove((ucmd:CommandNumber() % 2 == 0) and as_l or -as_l)
			end
		end

		ucmd:RemoveKey(IN_JUMP)
	end
end

/*
Chat Stuff
*/

local function chatspam1()
    if(!gBool("f", "Chat-Spams", "Enabled")) then return; end
local chatspam1 = gBool("f", "Chat-Spams","Chat-Spam1");
    if(chatspam1) then
        RunConsoleCommand("say", "If I wanted to suicide, i'd jump from your ego to your elo, just get good and get skeet.cc")
    end
end
timer.Create("chatspam1", 0.1,0,chatspam1)

local function chatspam2()
    if(!gBool("f", "Chat-Spams", "Enabled")) then return; end
local chatspam2 = gBool("f", "Chat-Spams","Chat-Spam2");
    if(chatspam2) then
        RunConsoleCommand("say", "Saleelul sawarim nasheedul ubah Wa darbul qitaly tariqul haya Fa baynaq tihamin yubidu tughaWa kateem musawtim jamilun sadah")
    end
end
timer.Create("chatspam2", 0.1,0,chatspam2)

local function chatspam3()
       if(!gBool("f", "Chat-Spams", "Enabled")) then return; end
local chatspam3 = gBool("f", "Chat-Spams","Chat-Spam3");
    if(chatspam3) then
        RunConsoleCommand("say", "noos.cc ==> dominate everything.")
    end
end
timer.Create("chatspam3", 0.1,0,chatspam3)

local function chatspam4()
    if(!gBool("f", "Chat-Spams", "Enabled")) then return; end
local chatspam4 = gBool("f", "Chat-Spams","Chat-Spam4");
    if(chatspam4) then
        RunConsoleCommand("say", "noos.cc ==> Best cheat in lua.")
    end
end
timer.Create("chatspam4", 0.1,0,chatspam4	)

local function chatspam5()
    if(!gBool("f", "Chat-Spams", "Enabled")) then return; end
local chatspam5 = gBool("f", "Chat-Spams","Chat-Spam5");
    if(chatspam5) then
        RunConsoleCommand("say", "noos.cc ==> Only a shitty C++ cannot beat lua.")
    end
end
timer.Create("chatspam5", 0.1,0,chatspam5)

local function WeaponShootable()
    local wep = pm.GetActiveWeapon(me);
    if( em.IsValid(wep) ) then // I would never get lazy..
             local n = string.lower(wep:GetPrintName())
             if( wep:Clip1() <= 0 ) then
                    return false;
                 end
                 
                 
                 
                 if( string.find(n,"knife") or string.find(n,"grenade") or string.find(n,"sword") or string.find(n,"bomb") or string.find(n,"ied") or string.find(n,"c4") or string.find(n,"slam") or string.find(n,"climb") or string.find(n,"hand") or string.find(n,"fist") ) then
                    return false;
                 end
                 
                 
                  return true;
        end
end
		local myAngles = me:GetAngles()

CreateClientConVar("_adminbox", "1", true, false)

local function adminboxshit()
	if(!gBool("c", "Misc", "Online Admins")) then return; end
	if GetConVarNumber( "_adminbox" ) != 1 then return end
	local shitheads = {}
	local shitheadrank = {}
	local l = 0

	
	
	for _, v in pairs( player.GetAll() ) do
		if not string.find(v:GetUserGroup(), "user") and not string.find(v:GetUserGroup(), "vip") and not string.find(v:GetUserGroup(), "VIP")  and not string.find(v:GetUserGroup(), "donator") and not string.find(v:GetUserGroup(), "trusted") and not string.find(v:GetUserGroup(), "Trusted") then 
			table.insert( shitheads, v:Name() )
			table.insert( shitheadrank, v:GetUserGroup() ) -- never used
		end
	end
	

	local textLength = surface.GetTextSize( table.concat(shitheads) )
	draw.RoundedBox(0, ScrW() - 175, ScrH() - ScrH() + 10, 155, 40, Color(170, 170, 170,255)) -- stay
	draw.RoundedBox(0, ScrW() - 170, ScrH() - ScrH() + 15, 145, 30, Color(50, 50, 50, 255)) -- stay
	
	if table.Count(shitheads) != 0 then
		draw.RoundedBox(0, ScrW() - 170, ScrH() - ScrH() + 55, 145, 20 * table.Count(shitheads), Color(0, 0, 0, 200))
	end
	
				draw.SimpleText("Admins", "Default", ScrW() - 115, ScrH() - ScrH() + 23, Color(255, 255, 255))
	
	for k, v in pairs(shitheads) do
		draw.SimpleText(v, "default", ScrW() - 155, ScrH() - ScrH() + 59 + l, Color(255, 255, 255, 255))
		l = l + 19
	end
end
hook.Add("HUDPaint", "adminboxhook", adminboxshit)

cvars.AddChangeCallback("_adminbox", function()
        if GetConVarNumber("_adminbox") == 1 then
                hook.Add("HUDPaint", "adminboxhook", adminboxshit)
        else
                hook.Remove("adminboxhook")
        end
end)




CreateClientConVar("_spectaterbox", "1", true, false)

local function specbox()
if(!gBool("c", "Misc", "Spectator List")) then return; end
   if GetConVarNumber( "_spectaterbox" ) != 1 then return end
   local specs = {}
   local alength = 0
   local specplys = player.GetAll()
   
   -- idk why i did it this way lmao
   for i = 1, #specplys do
    local v = specplys[i]
   
    if v:GetObserverTarget() == LocalPlayer() then
        table.insert(specs, v:Name())
    end
    end
 
   local textLength = surface.GetTextSize( table.concat(specs) )
    draw.RoundedBox(0, ScrW() - 355, ScrH() - ScrH() + 10, 155, 40, Color( 170, 170, 170)) -- stay
    draw.RoundedBox(0, ScrW() - 350, ScrH() - ScrH() + 15, 145, 30, Color( 59, 59, 59, 255)) -- stay
 
    if table.Count(specs) != 0 then
        draw.RoundedBox(1, ScrW() - 350, ScrH() - ScrH() + 55, 150, 20 * table.Count(specs), Color(59, 59, 59,200))
    end
    draw.SimpleText("Spectators", "default", ScrW() - 305, ScrH() - ScrH() + 23, Color(255, 255, 255))
   
 
    for _, v in pairs(specs) do
        draw.SimpleText(v, "default", ScrW() - 335, ScrH() - ScrH() + 59 + alength, Color(255, 255, 255, 255))
        alength = alength + 19
    end
end
hook.Add("HUDPaintBackground", "specboxhook", specbox)

 
cvars.AddChangeCallback("_spectaterbox", function()
        if GetConVarNumber("_spectaterbox") == 1 then
                hook.Add("HUDPaintBackground", "specboxhook", specboxshit)
        else
                hook.Remove("specboxhook")
        end
end)

hook.Add("HUDPaint", "", function()
    if(aimtarget && gBool("a", "Target", "Snapline")) then
        local pos = vm.ToScreen(em.LocalToWorld(aimtarget, em.OBBCenter(aimtarget)));
        surface.SetDrawColor(255, 255, 255);
        surface.DrawLine(ScrW() / 2, ScrH() / 2, pos.x, pos.y);
    end
    if(!gBool("c", "ESP", "Enabled")) then return; end
    for k,v in next, player.GetAll() do
        if(!em.IsValid(v) || em.Health(v) < 1 || v == me || em.IsDormant(v)) then continue; end
        if(!Filter(v)) then continue; end
        ESP(v);
    end
end);

hook.Add("RenderScreenspaceEffects", "", function()
    if(!gBool("c", "ESP", "Enabled")) then return; end
    for k,v in next, player.GetAll() do
        if(!em.IsValid(v) || em.Health(v) < 1 || v == me || em.IsDormant(v)) then continue; end
        if(!Filter(v)) then continue; end
        Chams(v);
    end
end);

--[[
memes
]]

local fa;
local aa;

local function FixMovement(ucmd, aaaaa)
    --local move = Vector(cm.GetForwardMove(ucmd), cm.GetSideMove(ucmd), 0);
    --local move = am.Forward( vm.Angle(move) + ( cm.GetViewAngles(ucmd) - fa ) ) * vm.Length(move);
    local move = Vector(cm.GetForwardMove(ucmd), cm.GetSideMove(ucmd), cm.GetUpMove(ucmd));
    local speed = math.sqrt(move.x * move.x + move.y * move.y);
    local ang = vm.Angle(move);
    local yaw = math.rad(cm.GetViewAngles(ucmd).y - fa.y + ang.y);
    cm.SetForwardMove(ucmd, (math.cos(yaw) * speed) * ( aaaaa && -1 || 1 ));
    cm.SetSideMove(ucmd, math.sin(yaw) * speed);
    --cm.SetForwardMove(ucmd, move.x);
    --cm.SetSideMove(ucmd, (aaaaa && move.y * -1 || move.y));
end

local function Clamp(val, min, max)
    if(val < min) then
        return min;
    elseif(val > max) then
        return max;
    end
    return val;
end

local function NormalizeAngle(ang)
    ang.x = math.NormalizeAngle(ang.x);
    ang.p = math.Clamp(ang.p, -89, 89);
end

--[[
aimer
]]

local table = Copy(table);
local dists = {};

local function GetPos(v)

    if(gBool("a", "Target", "Bodyaim")) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end

    local eyes = em.LookupAttachment(v, "eyes");
    
    if(!eyes) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end
    
    local pos = em.GetAttachment(v, eyes);
    
    if(!pos) then return( em.LocalToWorld(v, em.OBBCenter(v)) ); end
    
    return(pos.Pos);
end

local aimignore;

local function Valid(v)
    if(!v || !em.IsValid(v) || v == me || em.Health(v) < 1 || em.IsDormant(v) || pm.Team(v) == 1002 || (v == aimignore && gOption("a", "Target", "Selection") == "Nextshot")) then return false; end
    if(gBool("a", "Target", "Ignore Bots")) then
        if(pm.IsBot(v)) then return false; end
    end
    if(gBool("a", "Target", "Ignore Team")) then
        if(pm.Team(v) == pm.Team(me)) then return false; end
    end
    if(gBool("a", "Target", "Ignore Friends")) then
        if(pm.GetFriendStatus(v) == "friend") then return false; end
    end
    local tr = {
        start = em.EyePos(me),
        endpos = GetPos(v),
        mask = MASK_SHOT,
        filter = {me, v},
    };
    return(util.TraceLine(tr).Fraction == 1);
end

local function gettarget()

    local opt = gOption("a", "Target", "Selection");
    
    local sticky = gOption("a", "Aimbot", "Non-Sticky");
    
    if(opt == "Distance") then

        if( !sticky && Valid(aimtarget) ) then return; end

        dists = {};
        
        for k,v in next, player.GetAll() do
            if(!Valid(v)) then continue; end
            dists[#dists + 1] = { vm.Distance( em.GetPos(v), em.GetPos(me) ), v };
        end
        
        table.sort(dists, function(a, b)
            return(a[1] < b[1]);
        end);
        
        aimtarget = dists[1] && dists[1][2] || nil;
        
    elseif(opt == "Health") then
        
        if( !sticky && Valid(aimtarget) ) then return; end

        dists = {};
        
        for k,v in next, player.GetAll() do
            if(!Valid(v)) then continue; end
            dists[#dists + 1] = { em.Health(v), v };
        end
        
        table.sort(dists, function(a, b)
            return(a[1] < b[1]);
        end);
        
        aimtarget = dists[1] && dists[1][2] || nil;
        
    elseif(opt == "Nextshot") then
        if( !sticky && Valid(aimtarget) ) then return; end
        aimtarget = nil;
        local allplys = player.GetAll();
        local avaib = {};
        for k,v in next,allplys do
            avaib[math.random(100)] = v;
        end
        
        for k,v in next, avaib do
            if(Valid(v)) then
                aimtarget = v;
            end
        end
    end
        
end


local cones = {};

local nullvec = Vector() * -1;

local IsFirstTimePredicted = IsFirstTimePredicted;
local CurTime = CurTime;
local servertime=0;
local bit = Copy(bit);

hook.Add("Move", "", function()
    if(!IsFirstTimePredicted()) then return; end
    servertime = CurTime();
end);


GAMEMODE["EntityFireBullets"] = function(self, p, data)
    aimignore = aimtarget;
    local w = pm.GetActiveWeapon(me);
    local Spread = data.Spread * -1;
    if(!w || !em.IsValid(w) || cones[em.GetClass(w)] == Spread || Spread == nullvec) then return; end
    cones[em.GetClass(w)] = Spread;
end

local function PredictSpread(ucmd, ang)
    local w = pm.GetActiveWeapon(me);
    if(!w || !em.IsValid(w) || !cones[em.GetClass(w)] || !gBool("a", "Accuracy", "No Spread")) then return am.Forward(ang); end
    return(dickwrap.Predict(ucmd, am.Forward(ang), cones[em.GetClass(w)]));
end

local function Autofire(ucmd)
    if(pm.KeyDown(me, 1) && gBool("a", "Aimbot", "Auto Pistol")) then
        cm.SetButtons(ucmd, bit.band( cm.GetButtons(ucmd), bit.bnot( 1 ) ) );
    else
        cm.SetButtons(ucmd, bit.bor( cm.GetButtons(ucmd), 1 ) );
    end
end

local function WeaponCanFire()
    local w = pm.GetActiveWeapon(me);
    if(!w || !em.IsValid(w) || !gBool("a", "Aimbot", "Bullettime")) then return true; end
    return( servertime >= wm.GetNextPrimaryFire(w) );
end

local function WeaponShootable()
    local wep = pm.GetActiveWeapon(me);
    if( em.IsValid(wep) ) then // I would never get lazy..
         local n = string.lower(wep:GetPrintName())
         if( wep:Clip1() <= 0 ) then
            return false;
         end
         
         
         
         if( string.find(n,"knife") or string.find(n,"grenade") or string.find(n,"sword") or string.find(n,"bomb") or string.find(n,"ied") or string.find(n,"c4") or string.find(n,"slam") or string.find(n,"climb") or string.find(n,"hand") or string.find(n,"fist") ) then
            return false;
         end
          
          
          return true;
    end
end

local function PredictPos(pos)
local myvel = LocalPlayer():GetVelocity()
local pos = pos - (myvel * engine.TickInterval());
return pos;
end

local function aimer(ucmd)
	if(cm.CommandNumber(ucmd) == 0 || !gBool("a", "Aimbot", "Enabled")) then return; end
	gettarget();
	aa = false;
	if(aimtarget && (input.IsKeyDown(KEY_C) || gBool("a", "Aimbot", "Autosnap")) && WeaponCanFire() && WeaponShootable() ) then
		aa = true;
		local pos = GetPos(aimtarget) - em.EyePos(me);
		PredictPos(pos);
		local ang = vm.Angle( PredictSpread(ucmd, vm.Angle(pos)));
		NormalizeAngle(ang);
		cm.SetViewAngles(ucmd, ang);
		if(gBool("a", "Aimbot", "Autofire")) then
			Autofire(ucmd);
		end
		if(gBool("a", "Aimbot", "Silent")) then
			FixMovement(ucmd);
		else
			fa = ang;
		end
	end
end

--[[
antiaimer
]]

local oc=0;
local spin3 =  -39 + -181 + -630;
local fakea = -629;
local faked = -630 + math.random(1.3245 + -2.32444);

local function GetClosest()
	local ddists = {};

	local closest;

	for k,v in next, player.GetAll() do
	if(!Valid(v)) then continue; end
		ddists[#ddists + 1] = { vm.Distance( em.GetPos(v), em.GetPos(me) ), v };
	end

	table.sort(ddists, function(a, b)
		return(a[1] < b[1]);
	end);

	closest = ddists[1] && ddists[1][2] || nil;

	if(!closest) then return fa.y; end

	local pos = em.GetPos(closest);

	local pos = vm.Angle(pos - em.EyePos(me));

	return( pos.y );
end


local function walldetect()
	local eye = em.EyePos(me);
	local tr = util.TraceLine({
		start = eye,
		endpos = (eye + (am.Forward(fa) * 10)),
		mask = MASK_ALL,
	});
	if(tr.Hit) then
		op = -181;
		oy = -90;
	end
end

local ox=-181;
local oy=0

local function RandCoin()
	local randcoin = math.random(0,1);
	if(randcoin == 1) then return 1; else return -1; end
end

local function GetX()
	local opt = gOption("a", "Anti-Aim", "X");
	if(opt == "Emotion") then
		local randcoin = gInt("a", "Anti-Aim", "Emotion Random X");
		if( math.random(100) < randcoin ) then
			ox = RandCoin() * 181;
		end
	elseif( opt == "FakeAngle1" ) then
		 ox = -181.08792914142452 + math.random(2.28792914) + 91423423

     elseif( opt == "Fake Down" ) then
	     ox = -180.087929;
     elseif( opt == "Down X" ) then -- Glitch Gave me
	     ox = 39;
	elseif(opt == "Off") then
		ox = fa.x;
	elseif( opt == "Anti p$ilent" ) then
		ox = -142 + 85.001;
		ox = 2 + -1 +518
	elseif( opt == "Dank" ) then
		ox = -541;
	elseif( opt == "Down" ) then
		ox = -181;
	elseif( opt == "Up" ) then
		ox = 181;
	elseif(opt == "Jitter") then
		ox = ox * -1;
	end
end

local function GetClosest()
	local ddists = {};

	local closest;

	for k,v in next, player.GetAll() do
	if(!Valid(v)) then continue; end
		ddists[#ddists + 1] = { vm.Distance( em.GetPos(v), em.GetPos(me) ), v };
	end

	table.sort(ddists, function(a, b)
		return(a[1] < b[1]);
	end);

	closest = ddists[1] && ddists[1][2] || nil;

	if(!closest) then return fa.y; end

	local pos = em.GetPos(closest);

	local pos = vm.Angle(pos - em.EyePos(me));

	return( pos.y );
end

local spin3 =  -39 + -181 + -630;
local spin2 =  -181 + math.random(-2);
local spin =  0.2 + math.random(-2);
local fakeb = 170;
local fakec = -629;
local fakei = 081;

local function GetY()
	local opt = gOption("a", "Anti-Aim", "Y");
		if(opt == "Emotion") then
		local randcoin = gInt("a", "Anti-Aim", "Emotion Random Y");
		if( math.random(100) < randcoin ) then
			oy = fa.y + math.random(-180, 180);
		end

	elseif( opt == "Eye Angles" ) then
		oy = fa.y;
	elseif(opt == "Off") then
		ox = fa.x;
	elseif(opt == "Down Y") then
		oy = 39.7;
	elseif(opt == "Fast Spin") then
		spin = spin + 4;
		oy = - spin;
	elseif(opt == "Slow Spin") then
		spin2 = spin2 + 1;
		oy = spin2;
	elseif(opt == "Middle Spin") then
		spin2 = spin2 + 3;
		oy = - spin2;
	elseif( opt == "Fake AA" ) then
		oy = -630;
	elseif( opt == "Fake AA2" ) then
		oy = -00.1231234235 + math.random (-0.29) + math.random (0)
	elseif(opt == "FakeAngle1") then -- Woody Gave me
		oy = fa.y - 0.2 + math.random(-2)
	elseif(opt == "FakeAngle2") then -- Woody Gave me
		oy = fa.y - 0.1 + math.random(-7)
	elseif(opt == "Static") then
		oy = 0;
	elseif(opt == "Backwards") then
		oy = 180 + GetClosest();
	elseif(opt == "Fake Backwards") then
		oy = -180;
	end
end

local function walldetect()
	local eye = em.EyePos(me);
	local tr = util.TraceLine({
		start = eye,
		endpos = (eye + (am.Forward(fa) * 10)),
		mask = MASK_ALL,
	});
	if(tr.Hit) then
		ox = -181;
		oy = -90;
	end
end

local function normalizeAngle(ang)
	ang.p = math.NormalizeAngle(ang.p);
	ang.p = math.Clamp(ang.p, -89, 89);

	ang.y = math.NormalizeAngle(ang.y);
end

local function normalizeAngle(ang)
	ang.p = math.NormalizeAngle(-630);
	ang.p = math.Clamp(ang.p);

	ang.y = math.NormalizeAngle(-180 + math.random(1, 1.99999999999999999999));
end

local function antiaimer(ucmd)
	if( (cm.CommandNumber(ucmd) == 0 && !gBool("c", "Misc", "Thirdperson")) || cm.KeyDown(ucmd, 1) || cm.KeyDown(ucmd, 32) || aa || !gBool("a", "Anti-Aim", "Enabled")) then return; end
	GetX();
	GetY();
	walldetect();
	local aaang = Angle(ox, oy, 0);
	cm.SetViewAngles(ucmd, aaang);
	FixMovement(ucmd, true);
end

local function rapidfire(ucmd)
	if(pm.KeyDown(me, 1) and gBool("a", "Aimbot", "Auto Pistol")) then
		cm.SetButtons(ucmd, bit.band( cm.GetButtons(ucmd), bit.bnot( 1 ) ) )
	end
end

local function GetAngle(ang)
	if(!gBool("Aimbot", "Extra", "Anti Recoil")) then return ang + pm.GetPunchAngle(me); end
	return ang;
end

local function ArrivalPublic(ucmd)
	if(!fa) then fa = cm.GetViewAngles(ucmd); end
	fa = fa + Angle(cm.GetMouseY(ucmd) * .023, cm.GetMouseX(ucmd) * -.023, 0);
	NormalizeAngle(fa);
	if(cm.CommandNumber(ucmd) == 0) then
		cm.SetViewAngles(ucmd, GetAngle(fa));
		return;
	end
	if(cm.KeyDown(ucmd, 1)) then
		local ang = GetAngle(vm.Angle( PredictSpread(ucmd, fa ) ) );
		NormalizeAngle(ang);
		cm.SetViewAngles(ucmd, ang);
	end
end
hook.Add("CreateMove", "", function(ucmd)	
	Bunnyhop(ucmd);	
	autostrafe(ucmd);	
	pBhoop(ucmd);	
	ArrivalPublic(ucmd);
	aimer(ucmd);
	antiaimer(ucmd);
end);

function GAMEMODE:PreDrawSkyBox()
	if (!gBool("c", "Misc", "No Sky")) then return; end
	render.Clear(0, 0, 0, 255);
	return true;
end

local trace_walls = bit.bor(CONTENTS_TESTFOGVOLUME, CONTENTS_EMPTY, CONTENTS_MONSTER, CONTENTS_HITBOX);
local NoPenetration = {[MAT_SLOSH] = true};
local PenMod = {[MAT_SAND] = 0.5, [MAT_DIRT] = 0.8, [MAT_METAL] = 1.1, [MAT_TILE] = 0.9, [MAT_WOOD] = 1.2};
local trace_normal = bit.bor(CONTENTS_SOLID, CONTENTS_OPAQUE, CONTENTS_MOVEABLE, CONTENTS_DEBRIS, CONTENTS_MONSTER, CONTENTS_HITBOX, 402653442, CONTENTS_WATER);


local function fasAutowall(wep, startPos, aimPos, ply)
	if !gBool("a", "Accuracy", "Auto Wall") then return end;
    local traces = {};
    local traceResults = {};
    local dir = (aimPos - startPos):GetNormalized();
    traces[1] = { start = startPos, filter = me, mask = trace_normal, endpos = aimPos, };
    traceResults[1] = util.TraceLine(traces[1]);
    if(NoPenetration[traceResults[1].MatType]) then return false; end
    if(-dir:DotProduct(traceResults[1].HitNormal) <= .26) then return false; end

    traces[2] = { start = traceResults[1].HitPos, endpos = traceResults[1].HitPos + dir * wep.PenStr * (PenMod[traceResults[1].MatType] || 1) * wep.PenMod, filter = me, mask = trace_walls, };
    traceResults[2] = util.TraceLine(traces[2]);
    traces[3] = { start = traceResults[2].HitPos, endpos = traceResults[2].HitPos + dir * .1, filter = me, mask = trace_normal, };
    traceResults [3] = util.TraceLine(traces[3]);
    traces[4] = { start = traceResults[2].HitPos, endpos = aimPos, filter = me, mask = MASK_SHOT, };
    traceResults[4] = util.TraceLine(traces[4]);
    if(traceResults[4].Entity != ply) then return false; end
    return(!traceResults[3].Hit);
end


local oldRC = render.Capture
local rndrView = render.RenderView
takingss = false
render.Capture = function( ... )
	takingss = true
	rndrView()
	GAMEMODE:HUDPaint()
	takingss = false
	return oldRC( ... )
end

local function m9kAutowall(wep)
	if !gBool("Aimbot", "Accuracy", "Auto Wall") then return end;
	local wep = me:GetActiveWeapon();
    local trace = {
        endpos = aimPos, 
        start = me:EyePos(), 
        mask = MASK_SHOT, 
        filter = me,
    };
    return wep:BulletPenetrate(10, nil, util.TraceLine(trace), DamageInfo());
end

local function FixMovement(ucmd)
	local vec = Vector(cm.GetForwardMove(ucmd), cm.GetSideMove(ucmd), 0);
	local vel = math.sqrt(vec.x*vec.x + vec.y*vec.y);
	local mang = vm.Angle(vec);
	local yaw = cm.GetViewAngles(ucmd).y - fa.y + mang.y;
	if (((cm.GetViewAngles(ucmd).p+90)%360) > 180) then
	yaw = 180 - yaw;
	end
	yaw = ((yaw + 180)%360)-180;
	ucmd:SetForwardMove(math.cos(math.rad(yaw)) * vel);
	ucmd:SetSideMove(math.sin(math.rad(yaw)) * vel);
end


local toggler = 0
local function RapidFire(ucmd)
if(gBool("a", "Aimbot", "Rapid Fire")) then
	if me:KeyDown(IN_ATTACK) then
		if me:Health() > 0 then
			if IsValid(me:GetActiveWeapon()) and me:GetActiveWeapon():GetClass() != "weapon_physgun" then
				if toggler == 0 then
					ucmd:SetButtons(bit.bor(ucmd:GetButtons(), IN_ATTACK))
					toggler = 1
				else
					ucmd:SetButtons(bit.band(ucmd:GetButtons(), bit.bnot(IN_ATTACK)))
					toggler = 0
				end
				end
			end
		end
	end
end

        if(gBool("a", "Aimbot", "pSilent")) then
            bSendPacket = false;
        end

hook.Add("CalcView", "", function(p, o, a, f)
	return({
		angles = GetAngle(fa),
		origin = (gBool("c", "Misc", "Thirdperson") && o + am.Forward(fa) * -150 || o),
		fov = gInt("c", "Misc", "FOV"),
	});
end);

hook.Add("ShouldDrawLocalPlayer", "", function()
	return(gBool("c", "Misc", "Thirdperson"));
end);

local function NoSpread()         
if(gBool("a", "Aimbot", "No Spread")) then                             
local wep = LocalPlayer():GetActiveWeapon()
if wep.data then
wep.data.Recoil = 0
wep.data.Cone = 0
wep.data.Spread = 0
end
if wep.Primary then
wep.Primary.Recoil = 0
wep.Primary.Cone = 0
wep.Primary.Spread = 0
end
end
end
hook.Add("Tick", "NoSpread", NoSpread)

local NoSpread = CreateClientConVar( "NoSpread", 0)



hook.Add( "HUDPaint", "Rainbow Watermark", function()
if(!gBool("c", "Hud Paint", "Rainbow Watermark")) then return; end
	rainbow = {}
	rainbow.R = math.sin(CurTime() * 4) * 127 + 128
	rainbow.G = math.sin(CurTime() * 4 + 2) * 127 + 128
	rainbow.B = math.sin(CurTime() * 4 + 4) * 127 + 128

local h = ScrH() / 1
local w = ScrW() / 5
draw.SimpleText("FinooseWare", "WATERMARK", 10, 25, Color(rainbow.R, rainbow.B, rainbow.G), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
end)

hook.Add( "HUDPaint", "Velocity1", function()
	if(!gBool("c", "Hud Paint", "Rainbow Watermark")) then return; end
  	draw.SimpleText( "Speed : "..math.Round(me:GetVelocity():Length2D()), "WATERMARK", 10,27,Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 0.5, Color( 0, 0, 0, 255 ) )

end)


hook.Add( "HUDPaint", "Watermark", function()
if(!gBool("c", "Hud Paint", "Watermark")) then return; end
	rainbow = {}
	rainbow.R = math.sin(CurTime() * 4) * 127 + 128
	rainbow.G = math.sin(CurTime() * 4 + 2) * 127 + 128
	rainbow.B = math.sin(CurTime() * 4 + 4) * 127 + 128

local h = ScrH() / 1
local w = ScrW() / 5
draw.SimpleText("After.cc", "WATERMARK", 10, 25, Color(170, 170, 170), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
end)

hook.Add( "HUDPaint", "Velocity2", function()
	if(!gBool("c", "Hud Paint", "Watermark")) then return; end
  	draw.SimpleText( "Speed : "..math.Round(me:GetVelocity():Length2D()), "WATERMARK", 10,27,Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 0.5, Color( 0, 0, 0, 255 ) )
end)

hook.Add("PreDrawPlayerHands", "", function()
	if(gBool("f", "Viewmodel", "No Hands") || gBool("c", "Misc", "Thirdperson")) then
	return true;
	else
	return false;
	end
end);

local function Flashlight()
if(!gBool("f", "Misc", "Flashlight Spammer")) then return; end
	RunConsoleCommand("impulse", "100" )
end
timer.Create("Flashlight", 0.001, 0, Flashlight)

/* Traitor Finder */

local matOverlay = Material( "sprites/glow08" )
local matTraitor = Material( "sprites/dot" )
local twep = { "weapon_ttt_c4", "weapon_ttt_knife", "weapon_ttt_phammer", "weapon_ttt_sipistol", "weapon_ttt_flaregun", "weapon_ttt_push", "weapon_ttt_radio", "weapon_ttt_teleport", "(Disguise)", "weapon_ttt_trait_defilibrator", "weapon_ttt_xbow", "weapon_ttt_dhook", "weapon_awp", "weapon_jihad", "weapon_ttt_knife", "weapon_ttt_c4", "weapon_ttt_decoy", "weapon_ttt_flaregun", "weapon_ttt_phammer", "weapon_ttt_push", "weapon_ttt_radio", "weapon_ttt_sipistol", "weapon_ttt_teleport", "weapon_ttt_awp", "weapon_ttt_silencedsniper", "weapon_ttt_turtlenade", "weapon_ttt_death_station", "weapon_ttt_sg552", "weapon_ttt_tripmine"}

for _,v in pairs(player.GetAll()) do
        v.HatTraitor = nil
end
for _,v in pairs(ents.GetAll()) do
        v.HatESPTracked = nil
end

hook.Add("PostDrawOpaqueRenderables", "wire_animations_idle", function()
	if(!gBool("f", "Misc", "Traitor Finder")) then return; end
        if GAMEMODE.round_state != ROUND_ACTIVE then
                for _,v in pairs(player.GetAll()) do
                        v.HatTraitor = nil
                end
                for _,v in pairs(ents.GetAll()) do
                        v.HatESPTracked = nil
                end
                return
        end
        for _,v in pairs( ents.GetAll() ) do
                if v and IsValid(v) and (table.HasValue(twep, v:GetClass()) and !v.HatESPTracked) then
                        local pl = v.Owner
                        if pl and IsValid(pl) and pl:IsTerror() then
                                if pl:IsDetective() then
                                        v.HatESPTracked = true
                                else
                                        v.HatESPTracked = true
                                        pl.HatTraitor = true
                                        chat.AddText( pl, Color(255,125,0), " is a ",Color(255,0,0), "Traitor",Color(255,125,0), " with a ",Color(255,0,0),v:GetClass())
                                        RunConsoleCommand("say" , pl, " is a traitor")
					            end
                        end
                end
        end



end)



local function HideShit( name )
if(!gBool("c", "Hud Paint", "Crosshair")) then return; end
	if(name == "CHudCrosshair") then
             return false
        end
        -- We don't return anything here otherwise it will overwrite all other
        -- HUDShouldDraw hooks.
end
hook.Add( "HUDShouldDraw", "HideShit", HideShit )

hook.Add( "HUDPaint", "Crosshair", function() -- Taken from death.bot thanks i guess. probs taken from like luabot :)
		local curcol = Color(gInt("d", "Crosshair Color", "R") / 2, gInt("d", "Crosshair Color", "G") / 2, gInt("d", "Crosshair Color", "B"))
	if(!gBool("c", "Hud Paint", "Crosshair")) then return; end
	surface.SetDrawColor(170, 170, 170) -- rainbow.R, rainbow.G, rainbow.B
	local x = ScrW() * 0.5
	local y = ScrH() * 0.5
	surface.DrawLine( x + 11, y, x - 12, y )
	surface.DrawLine( x, y + 11, x, y - 12 )
	surface.SetDrawColor( curcol ) -- rainbow.R, rainbow.G, rainbow.B
	local x = ScrW() * 0.5
	local y = ScrH() * 0.5
	surface.DrawLine( x + 10, y, x - 10, y )
	surface.DrawLine( x, y + 10, x, y - 10 )
	end)

local wireframeMat = Material("models/wireframe");
hook.Add("PreDrawViewModel", "", function()
	if(!gBool("f", "Viewmodel", "Wireframe") || gBool("c", "Misc", "Thirdperson")) then return; end
	local WepMat = Material("models/wireframe")
	render.MaterialOverride(WepMat);
	render.SetColorModulation(gInt("f", "Viewmodel", "R") /255,gInt("f", "Viewmodel", "G") /255,gInt("f", "Viewmodel", "B") /255);
end);


function newcvar( Name, Str )
	Msg( "Auto-dance Loaded!" )
	CreateClientConVar( Name, Str, true, false )
end

newcvar( "auto_dance", 0 )


function dance()
if GetConVarNumber( "auto_dance" ) == 1 then
RunConsoleCommand( "act", "dance" )
end
end
hook.Add( "Think", "dance", dance )

--------------------------------------------------------
function newcvar( Name, Str )
	CreateClientConVar( Name, Str, true, false )
end

newcvar( "auto_bow", 0 )


function dance()
if GetConVarNumber( "auto_bow" ) == 1 then
RunConsoleCommand( "act", "bow" )
end
end
hook.Add( "Think", "bow", dance )

-----------------------------------------------------------
function newcvar( Name, Str )
	Msg( "Auto-dance Loaded!" )
	CreateClientConVar( Name, Str, true, false )
end

newcvar( "auto_zombie", 0 )


function dance()
if GetConVarNumber( "auto_zombie" ) == 1 then
RunConsoleCommand( "act", "zombie" )
end
end
hook.Add( "Think", "zombie", dance )

-----------------------------------------------------------
function newcvar( Name, Str )
	CreateClientConVar( Name, Str, true, false )
end

newcvar( "auto_muscle", 0 )


function dance()
if GetConVarNumber( "auto_muscle" ) == 1 then
RunConsoleCommand( "act", "muscle" )
end
end
hook.Add( "Think", "muscle", dance )

-----------------------------------------------------------
function newcvar( Name, Str )
	CreateClientConVar( Name, Str, true, false )
end

newcvar( "auto_robot", 0 )


function dance()
if GetConVarNumber( "auto_robot" ) == 1 then
RunConsoleCommand( "act", "robot" )
end
end
hook.Add( "Think", "robot", dance )

-----------------------------------------------------------